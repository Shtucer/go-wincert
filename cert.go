// MACHINE GENERATED BY 'go generate' COMMAND; DO NOT EDIT

package wincert

import "unsafe"
import "syscall"

var _ unsafe.Pointer

var (
	modcrypt32  = syscall.NewLazyDLL("crypt32.dll")
	modadvapi32 = syscall.NewLazyDLL("advapi32.dll")

	procCertGetNameStringW                = modcrypt32.NewProc("CertGetNameStringW")
	procCertCreateSelfSignCertificate     = modcrypt32.NewProc("CertCreateSelfSignCertificate")
	procCertStrToNameW                    = modcrypt32.NewProc("CertStrToNameW")
	procCryptGenKey                       = modadvapi32.NewProc("CryptGenKey")
	procCertSetCertificateContextProperty = modcrypt32.NewProc("CertSetCertificateContextProperty")
	procPFXExportCertStoreEx              = modcrypt32.NewProc("PFXExportCertStoreEx")
)

func CertGetNameString(ctx *syscall.CertContext, typeName uint32, flags uint32, paraType uintptr, outBuffer *uint16, bufferSize uint32) (outSize uint32, err error) {
	r0, _, e1 := syscall.Syscall6(procCertGetNameStringW.Addr(), 6, uintptr(unsafe.Pointer(ctx)), uintptr(typeName), uintptr(flags), uintptr(paraType), uintptr(unsafe.Pointer(outBuffer)), uintptr(bufferSize))
	outSize = uint32(r0)
	if outSize == 0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CertCreateSelfSignedCertificate(cryptProvOrCryptKey syscall.Handle, subjectIssuer *CertNameBlob, flags uint32, keyProvInfo *KeyProvInfo, signAlgorithm *AlgorithmIdentifier, startTime *SystemTime, endTime *SystemTime, extensions *CertExtensions) (certContext *syscall.CertContext, err error) {
	r0, _, e1 := syscall.Syscall9(procCertCreateSelfSignCertificate.Addr(), 8, uintptr(cryptProvOrCryptKey), uintptr(unsafe.Pointer(subjectIssuer)), uintptr(flags), uintptr(unsafe.Pointer(keyProvInfo)), uintptr(unsafe.Pointer(signAlgorithm)), uintptr(unsafe.Pointer(startTime)), uintptr(unsafe.Pointer(endTime)), uintptr(unsafe.Pointer(extensions)), 0)
	certContext = (*syscall.CertContext)(unsafe.Pointer(r0))
	if certContext == nil {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CertStrToName(encodingType uint32, strX509 *uint16, strType uint32, reserved uintptr, outBuffer *byte, bufferSize *uint32, outError **uint16) (err error) {
	r1, _, e1 := syscall.Syscall9(procCertStrToNameW.Addr(), 7, uintptr(encodingType), uintptr(unsafe.Pointer(strX509)), uintptr(strType), uintptr(reserved), uintptr(unsafe.Pointer(outBuffer)), uintptr(unsafe.Pointer(bufferSize)), uintptr(unsafe.Pointer(outError)), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CryptGenKey(cryptProv syscall.Handle, algID uint32, flags uint32, hKey *syscall.Handle) (err error) {
	r1, _, e1 := syscall.Syscall6(procCryptGenKey.Addr(), 4, uintptr(cryptProv), uintptr(algID), uintptr(flags), uintptr(unsafe.Pointer(hKey)), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CertSetCertificateContextProperty(certCtx *syscall.CertContext, propId uint32, flags uint32, propertyData uintptr) (err error) {
	r1, _, e1 := syscall.Syscall6(procCertSetCertificateContextProperty.Addr(), 4, uintptr(unsafe.Pointer(certCtx)), uintptr(propId), uintptr(flags), uintptr(propertyData), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func PfxExportCertStore(storeHandle syscall.Handle, pfxBlob *CryptoApiBlob, password *uint16, data uintptr, flags uint32) (err error) {
	r1, _, e1 := syscall.Syscall6(procPFXExportCertStoreEx.Addr(), 5, uintptr(storeHandle), uintptr(unsafe.Pointer(pfxBlob)), uintptr(unsafe.Pointer(password)), uintptr(data), uintptr(flags), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}
